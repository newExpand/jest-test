# jest 공부 문서

## expect

jest 테스트의 핵심 구문

### **사용방법**

-   expect 안에 사용구문을 넣음으로써 예측에 들어맞는지 확인하기 위함
    expect(사용구문)

-   matcher를 사용하여 expect의 유형을 정함
    expect(사용구문).toBeInTheDocument() => matcher 사용

-   toBeInTheDocument => 요소가 문서에 있거나 없는 것을 테스트 할 수 있음 (인수 X)
    toBeInTheDocument 같이 DOM 기반의 matcher는 가상돔에서만 사용 가능
    DOM 기반 매쳐에는 toBeVisible, toBeChecked 같은 matcher도 있다

-   toBe => tobe('hello') 인 경우 hello 란 글자가 있어야 함
-   toHaveLength => toHaveLength(7) 배열요소의 7 길이를 예상할 수 있음

-   test 사용법
    test(테스트 이름) => 실패시 테스트 이름을 통해 어떤 테스트가 실패 했는지 알게 된다.

### **jest 특징**

-   jest의 테스트는 마지막 커밋 이후 변경된 파일에 한해 테스트한다.
-   빈 공백 일 땐 테스트에 통과 하며, throw new Error 구문을 사용하면 에러가 생기며 테스트에 실패하게 된다.

### **테스트 주도 개발 TDD란?**

-   TDD는 코드 작성 전에 테스트를 작성하고 테스트에 통과하도록 코드를 작성하는 것

**1. 테스트 기법**

-   레드 그린 테스트 기법
    1. 일단 빈 함수를 만들면 함수가 아무것도 하지 않기 때문에 테스트에 실패하게 됨
    2. 그 다음으로 코드를 작성해서 테스트에 통과하게 함

**2. TDD를 사용하는 이유**

-   테스트를 작성하는 것이 프로세스의 한 부분으로 느끼는 방식에 차이가 있다.
    -   대부분 사람들이 테스트를 마지막에 해야 하는 따분한 일이라 생각하지만 엄연히 테스트는 코딩 프로세스의 일부이다. 처음부터 해나가다 보면 코드 완료 후에도 번거로운 일처럼 느껴지지 않을 것이다.
-   효율적이다.
    -   어플리케이션을 실행해서 원하는 대로 작동하는지 확인하면서 소프트웨어를 업데이트 할 텐데 이는 수동테스트 이다.
    -   하지만, 코드 작성 전에 테스트를 작성하면 변경 후에 자동으로 다시 실행할 수 있다.
    -   그러한 이유로, 개발하면서 모든 테스트를 작성해 두면 변경 사항이 생길 때마다 모든 테스트를 다시 실행해서 자동 회귀 테스트를 할 수 있다. 이러면 변경 사항 확인을 위해 애플리케이션을 열고 수동으로 테스트할 필요가 없어진다.

### react-testing-library 의 철학(모범사례)

**1. RTL의 역할은 무엇이며 왜 사용할까?**

-   RTL은 테스트를 위한 가상 DOM을 생성하고 DOM과 상호 작용하기 위한 유틸리티도 제공 (예를 들어, DOM에서 요소를 찾을 수 있거나, 클릭과 같은 요소와 상호 작용할 수 있다.)
-   브라우저 없이도 테스트 가능하게 합니다.

**2. 테스트 유형**
테스트 유형을 알아보고 RTL이 이러한ㅌ테스트에 얼마나 적합한지 살펴보자.

-   **유닛 테스트**
    보통 함수나 별개의 React 컴포넌트 코드의 한 유닛 혹은 단위를 테스트하는 것. 이 유닛이 다른 코드의 유닛과 상호 작용하는 것을 테스트 하지 않음

-   **통합 테스트**
    여러 유닛이 함께 작동하는 방식을 테스트해서 유닛 간의 상호 작용을 테스트하는 것
    -   예를 들어 컴포넌트 간의 상호 작용을 테스트하거나 마이크로 서비스 간의 상호 작용을 테스트 합니다.
-   **기능 테스트**
    소프트웨어의 특정 기능을 테스트 하는 것. 코드가 아닌 동작을 테스트 한다고 생각하면 좀 더 편하다.
    예시) 데이터를 폼에 입력하고 제출을 클릭하면 소프트웨어가 특정 데이터 세트로 바르게 작동하는 기능을 확인하는 것
-   **인수테스트 혹은 E2E 테스트**
    이 테스트는 실제 브라우저가 필요하고, 애플리케이션이 연결된 서버가 필요하다.
    보통 Cypress나 Selenium 같은 도구를 사용하며, 이 테스트는 RTL을 위해 설계된 테스트가 아니다.

### 유닛 테스트 vs 기능 테스트

-   유닛 테스트
    -   테스트를 최대한 격리시킨다.
    -   함수나 컴포넌트를 테스트할 때 의존성을 표시(다른 의존성이 있거나 컴포넌트가 의존하는 다른 함수가 있으면 실제 버전 대신 테스트 버전을 사용)
    -   실패의 핀포인트를 잘잡을 수 있으나 사용자가 소프트웨어와 상호작용하는 방식과는 거리가 멀다 그래서 상호작용하는데 문제가 없어도 테스트는 실패 할 수 도 있다.
    -   리팩토링으로 실패할 가능성도 있다.
-   기능 테스트
    -   테스트 하는 특정 동작이나 유저 플로우와 연관된 모든 단위를 포함한다.
    -   장점은 사용자가 소프트웨어와 상호 작용하는 방식과 밀접하다는 것
        즉, 테스트에 통과하면 사용자에게 문제가 없고 테스트에 실패하면 사용자에게 문제가 발생할 가능성이 높다는 것을 의미 => 테스트가 견고함을 의미
    -   코드 작성방식을 리팩토링 해도 동작이 동일하게 유지되는 한 테스트도 통과하게 된다.
    -   단점으론 실패한 테스트를 디버깅하기 어려운 점이 단점이다. 어떤 부분의 코드가 테스트 실패의 원인인지 정확히 알 수 없다.
    -   결론: 전반적으로 RTL은 기능 테스트의 장점이 단점을 보안한다

### 테스팅 라이브러리와 접근성

**참고할 페이지**

테스팅 라이브러리
https://testing-library.com/docs/queries/about/#priority

테스팅 라이브러리에서 역할(Role)에 대한 접근성 참고 페이지
https://www.w3.org/TR/wai-aria/#role_definitions

커스텀 matcher 함수에 무엇이 있는지 참고할 페이지
https://github.com/testing-library/jest-dom
